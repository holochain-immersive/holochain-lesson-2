<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <meta name="Description" content="Put your description here." />
    <base href="/" />

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        background-color: #ededed;
        --r-main-font-size: 24px;
        --r-heading-margin: 20px 0 12px 0;
      }

      .slides {
        width: 75% !important;
      }

      .container {
        top: 0 !important;
        display: flex !important;
        flex-direction: row !important;
      }
      .column {
        display: flex;
        flex-direction: column;
      }
      .row {
        display: flex;
        flex-direction: row;
      }

      ul {
        width: 100%;
      }

      section {
        text-align: left;
      }

      .popover {
        position: absolute;
        background-color: #4d4d4d;
        padding: 1rem 2rem;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
        border-radius: 10px;
        width: auto;
        transform: translate(16px, -15px);
      }
      .popover:after {
        content: "";
        position: absolute;
        top: 6px;
        left: -8px;
        border-style: solid;
        border-width: 18px 12px 0;
        border-color: #4d4d4d transparent;
        display: block;
        width: 0;
        z-index: 1;
        transform: translate(-50%, 50%) rotate(90deg);
      }

      .popover .hljs-meta,
      .popover .hljs-class,
      .popover .hljs-keyword,
      .popover .hljs-string,
      .popover .hljs-title {
        color: rgb(221, 221, 221) !important;
        font-weight: normal;
      }

      .reveal pre code {
        max-height: 800px !important;
      }

      .dna {
        background-color: green;
      }
      .zome {
        background-color: blue;
      }
      .coordinator-zomes {
        background-color: lightblue;
      }

      .dna,
      .cell,
      .zome,
      .coordinator-zomes,
      .source-chain,
      .happ-bundle,
      .box,
      .dna-bundle,
      .dht-shard,
      .conductor,
      .happ {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
        border-width: 3px;
        border-color: rgb(209, 209, 209);
        border-style: solid;
      }
    </style>
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />

    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/dist/theme/black.css"
    />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/plugin/highlight/monokai.css"
    />
    <title>Holochain Lesson 2</title>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>HDK: basic functions</h1>
        </section>

        <section>
          <h3>HDK</h3>

          <li class="fragment fade-in-then-semi-out">
            Holochain Development Kit
          </li>
          <li class="fragment fade-in-then-semi-out">
            To create a zome, create a rust crate that depends on the HDK and
            compile it
          </li>
          <li class="fragment fade-in-then-semi-out">
            Allows to define zome functions that can be called from outside the
            zome
          </li>
          <li class="fragment fade-in-then-semi-out">
            Docs at https://docs.rs/hdk
          </li>
        </section>

        <section>
          <h3>Defining Zome Functions</h3>

          <pre
            class="fragment fade-in"
          ><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">use hdk::prelude::*;

<span class="fragment fade-in-then-semi-out">#[hdk_extern] <span class="fragment fade-in-then-out popover"><li class="fragment fade-in-then-semi-out">Comes from hdk::prelude::*</li><li class="fragment fade-in-then-semi-out">Exposes a function to be callable</li><li class="fragment fade-in-then-semi-out">Zome function name must be unique in this zome</li></span><span class="fragment fade-in"> // Exposes a function to be callable from the outside</span>
fn zome_function_a(<span class="fragment fade-in">name: String</span><span class="fragment fade-in-then-out popover">Zome functions can only accept one parameter</span>) <span class="fragment fade-in">-> ExternResult&lt;String&gt;<span class="fragment fade-in-then-out popover">Must return an "ExternResult&lt;T&gt;"</span></span> {
  <span class="fragment fade-in">Ok(format!("hello {}!", name))</span>
}
</span>

<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn zome_function_b(<span class="fragment fade-in">_: ()</span><span class="fragment fade-in-then-out popover">No input parameters</span>) -> ExternResult&lt;String&gt; { <span class="fragment fade-in-then-semi-out">// () denotes no input params </span>
  Ok(format!("hello world!"))
}
</span>

<span class="fragment fade-in-then-semi-out">struct InputStructC {
  name: String
}
<span class="fragment fade-in-then-semi-out">
#[hdk_extern]
fn zome_function_c(<span class="fragment fade-in"><span class="fragment fade-in-then-out popover" style="left: 300px">Input parameters must derive "Serialize", "Deserialize" and "Debug"</span><span class="fragment strike">input: InputStructC</span></span>) -> ExternResult&lt;String&gt; { <span class="fragment fade-in">// Doesn't derive "Serialize", "Deserialize" and "Debug"</span>
  Ok(format!("hello {}!", input.name))
}
</span>
</span>

<span class="fragment fade-in-then-semi-out">#[derive(Serialize, Deserialize, Debug)]
struct InputStructD {
  name: String
}
<span class="fragment fade-in-then-semi-out">
#[hdk_extern]
fn zome_function_d(<span class="fragment fade-in">input: InputStructD</span>) -> ExternResult&lt;String&gt; { <span class="fragment fade-in">// Ok</span>
  Ok(format!("hello {}!", input.name))
}
</span>

<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn zome_function_e(_: ()) -> ExternResult&lt;()&gt; { 
  <span class="fragment fade-in">Err(<span class="fragment fade-in">wasm_error!(WasmErrorInner::Guest(<span class="fragment fade-in-then-out popover">Captures debugging information (eg. line numbers)</span><span class="fragment fade-in">String::from("This function returns an error")</span>))</span>)</span>
}
</span>
</span>

</span></code></pre>
        </section>

        <section>
          <h3>Cell Information</h3>

          <li class="fragment fade-in-then-semi-out">Static information retrieval</li>

          <pre
            class="fragment fade-in"
          ><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">use hdk::prelude::*;

<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn get_my_pub_key(_: ()) <span class="fragment fade-in">-> ExternResult&lt;AgentPubKey&gt;<span class="fragment fade-in-then-out popover">Acts as the "agent ID"</span></span> {
  <span class="fragment fade-in">let my_info = agent_info()?;</span><span class="fragment fade-in-then-out popover">Will return a different value depending on which cell is executing the function</span><span class="fragment fade-in"> // Depends on which cell is executing this function</span>

  <span class="fragment fade-in">let my_pub_key: AgentPubKey = my_info.agent_initial_pubkey;<span class="fragment fade-in-then-out popover">"agent_initial_pubkey": In the future the public key of a cell may change </span></span>

  <span class="fragment fade-in">Ok(my_pub_key)</span>
}</span>
            
<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn get_zome_name(_: ()) <span class="fragment fade-in">-> ExternResult&lt;ZomeName&gt;<span class="fragment fade-in-then-out popover">A simple struct wrapping a String</span></span> {
  <span class="fragment fade-in">let info = zome_info()?;</span><span class="fragment fade-in-then-out popover">Will return a different value depending on which zome is the function defined, but will return the same for all agents</span><span class="fragment fade-in"> // Depends on which zome is the function defined</span>

  <span class="fragment fade-in-then-semi-out">let zome_name: ZomeName = info.name;</span><span class="fragment fade-in-then-out popover">Human readable name, defined in the DNA manifest</span><span class="fragment fade-in"> // Human readable name</span>
  <span class="fragment fade-in-then-semi-out">let zome_id: ZomeId = info.id;</span><span class="fragment fade-in-then-out popover">Zome index in the DNA that Holochain uses to identify the zome </span><span class="fragment fade-in"> // Zome index (integer)</span>

  <span class="fragment fade-in">Ok(zome_name)</span>
}</span>

<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn get_dna_hash(_: ()) <span class="fragment fade-in">-> ExternResult&lt;DnaHash&gt;</span> {
  <span class="fragment fade-in">let info = dna_info()?;</span><span class="fragment fade-in-then-out popover">Will return the same value for all agents and zomes in the same DNA</span><span class="fragment fade-in"> // Will return the same value for all agents and zomes in the same DNA</span>

  <span class="fragment fade-in-then-semi-out">let dna_name: String = info.name;</span><span class="fragment fade-in-then-out popover">Human readable name, defined in the DNA manifest</span><span class="fragment fade-in"> // Human readable name</span>
  <span class="fragment fade-in-then-semi-out">let hash: DnaHash = info.hash;</span><span class="fragment fade-in-then-out popover">Hash of source code, UID and properties </span><span class="fragment fade-in"> // Hash of source code, UID and properties</span>
  <span class="fragment fade-in-then-semi-out">let properties = info.properties;</span><span class="fragment fade-in-then-out popover">Properties: configuration that the DNA can read to modify it's behaviour </span><span class="fragment fade-in"> // Properties of the DNA</span>
  <span class="fragment fade-in-then-semi-out">let admin_pub_key = AgentPubKey::try_from(properties<span class="fragment fade-in-then-out popover">"properties" is of type "SerializedBytes": it can serialize to any rust type that derives "Serialize" and "Deserialize"</span>)?;</span><span class="fragment fade-in"> // Decoding the properties</span>


  <span class="fragment fade-in">Ok(hash)</span>
}</span>
</span></code></pre></section>


        <section>
          <h3>Defining Entries</h3>

          <li class="fragment fade-in-then-semi-out">
            Only in integrity zomes
          </li>
          <li class="fragment fade-in-then-semi-out">
            HDI: Holochain Deterministic integrity
            <ul>
              <li class="fragment fade-in-then-semi-out">
                Subset of the HDK to build integrity zomes
              </li>
            </ul>
          </li>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/integrity/lib.rs
use hdi::prelude::*;

<span class="fragment fade-in"><span class="fragment fade-in">#[hdk_entry_helper]<span class="fragment popover fade-in-then-out">Adds necessary trait implementations</span></span><span class="fragment fade-in"> // Adds necessary trait implementations</span>
struct Comment {
  comment: String
}

<span class="fragment fade-in">#[hdk_entry_helper]
struct Post {
  title: String,
  content: String
}</span>


<span class="fragment fade-in"><span class="fragment fade-in">#[hdk_entry_defs]</span><span class="fragment popover fade-in-then-out"><li class="fragment fade-in-then-semi-out">Defines all the entries for this zome</li><li class="fragment fade-in-then-semi-out">Must be the only "#[hdk_entry_def]" in the zome</li><li class="fragment fade-in-then-semi-out">Can only be defined in integrity zomes</li></span><span class="fragment fade-in"> // Defines all the entries for the zome</span>
<span class="fragment fade-in">#[unit_enum(UnitEntryTypes)]<span class="fragment popover fade-in-then-out">Defines a "UnitEntryTypes" enum that's a copy of "EntryTypes" but with the converted variants to unit variants (no payload)  </span></span><span class="fragment fade-in"> // Redefines the "EntryTypes" enum but with unit variants</span>
enum EntryTypes { // Enum with each entry type as a variant
  <span class="fragment fade-in">#[entry_def<span class="fragment popover fade-in-then-out">Configure entry behaviour</span>(<span class="fragment fade-in">name = "comment"</span><span class="fragment fade-in">, visibility = "private"<span class="fragment fade-in-then-out popover"><li class="fragment fade-in-then-semi-out">Comments won't be published to the DHT</li><li class="fragment fade-in">Only stored privately in the source chain</li></span></span>)]</span><span class="fragment fade-in"> // Configure entry behaviour</span>
  Comment(Comment),
  <span class="fragment fade-in-then-out popover">#[entry_def] can be omitted, defaults to the struct name in snake_case and visibility "public"</span><span class="fragment fade-in">// defaults to name = "post", visibility = "public"</span>
  Post(Post),
}
</span></span>
</span></code></pre>
        </section>

        <section>
          <h3>Entry Actions</h3>
          <h4 class="fragment fade-in">create_entry()</h4>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/coordinator/lib.rs
use hdk::prelude::*;
<span class="fade-in">use integrity_zome::{EntryTypes, Comment}; // Import the types defined in our integrity zome</span>

<span class="fragment fade-in">#[hdk_extern]
fn create_comment_a(comment: Comment) -> ExternResult&lt;()&gt; {
  <span class="fragment fade-in">create_entry(<span class="fragment fade-in-then-out popover">Comes from hdk::prelude::*;</span><span class="fragment fade-in">EntryTypes::Comment(comment)</span><span class="fragment popover fade-in-then-out">Input must be an instance of the entry types enum</span>)?;<span class="fragment fade-in"> // Input must be an instance of the entry types enum</span>

  Ok(())</span>
}</span>

<span class="fragment fade-in">#[hdk_extern]
fn create_comment_b(comment: Comment) -> ExternResult&lt;ActionHash&gt; {
  <span class="fragment fade-in"><span class="fragment fade-in">let action_hash = </span><span class="fragment fade-in-then-out popover">Returns the hash of the resulting action that has just been created in the source chain</span>create_entry(EntryTypes::Comment(comment))?; <span class="fragment fade-in-then-semi-out"> // Returns the hash of the resulting action </span>

  <span class="fragment fade-in">Ok(action_hash)</span></span>
}</span></span>
  
          </code></pre>
        </section>

        <section>
          <h3>Entry Actions</h3>
          <h4 class="fragment fade-in">update_entry()</h4>

          <li class="fragment fade-in-then-semi-out">
            Must be scoped to an action, not an entry
            <ul>
              <li class="fragment fade-in-then-semi-out">
                It may be ambiguous which of several valid actions pointing to
                the same entry you intend to update
              </li>
            </ul>
          </li>
          <li class="fragment fade-in-then-semi-out">
            Original entry and action will still exist in the DHT after update
          </li>
          <li class="fragment fade-in-then-semi-out">
            One action may be updated multiple times
          </li>
          <li class="fragment fade-in-then-semi-out">
            It's up to the application to interpret what "updating an action"
            means
          </li>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/coordinator/lib.rs
use hdk::prelude::*;
use integrity_zome::{EntryTypes, Comment}; // Import the types defined in our integrity zome

<span class="fragment fade-in-then-semi-out">
#[derive(Serialize, Deserialize, Debug)]
pub struct UpdateCommentInput {
  original_action_hash: ActionHash,
  new_comment: Comment
}</span>

<span class="fragment fade-in-then-semi-out">
#[hdk_extern]
fn update_comment(input: UpdateCommentInput) -> ExternResult&lt;ActionHash&gt; {
  let action_hash = <span class="fragment fade-in-then-semi-out">update_entry(<span class="fragment fade-in">input.original_action_hash</span><span class="fragment popover fade-in-then-out">The original comment action can be a create or an update</span>, <span class="fragment fade-in">input.new_comment</span><span class="fragment popover fade-in-then-out">Entry must be of the same type</span>)?;</span>

  Ok(action_hash)
}</span></span></code></pre>
        </section>

        <section>
          <h3>Entry Actions</h3>
          <h4 class="fragment fade-in">delete_entry()</h4>

          <li class="fragment fade-in-then-semi-out">
            Must be scoped to an action, not an entry
            <ul>
              <li class="fragment fade-in-then-semi-out">
                It may be ambiguous which of several valid actions pointing to
                the same entry you intend to delete
              </li>
            </ul>
          </li>
          <li class="fragment fade-in-then-semi-out">
            Deleted entry and action will still exist in the DHT after deleting
            <ul>
              <li class="fragment fade-in-then-semi-out">
                We are just marking them as "deleted"
              </li>
            </ul>
          </li>
          <li class="fragment fade-in-then-semi-out">
            One action may be deleted multiple times
          </li>
          <li class="fragment fade-in-then-semi-out">
            It's up to the application to interpret what "deleting an action"
            means
          </li>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/coordinator/lib.rs
use hdk::prelude::*;
use integrity_zome::{EntryTypes, Comment}; // Import the types defined in our integrity zome

<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn delete_comment(<span class="fragment fade-in">comment_action_hash: ActionHash</span>) -> ExternResult&lt;()&gt; {<span class="fragment fade-in">
  <span class="fragment fade-in">let action_hash =<span class="fragment popover fade-in-then-out">Deleting an entry is also its own action</span></span> delete_entry(<span class="fragment fade-in">comment_action_hash</span><span class="fragment popover fade-in-then-out">The original comment action can be a create or an update</span>)?;<span class="fragment fade-in"> // Deleted action hash must be a create or an update action </span>

  <span class="fragment fade-in-then-semi-out">Ok(())</span></span>
}</span></span></code></pre>
        </section>

        <section>
          <h3>Entry Retrievals</h3>
          <h4 class="fragment fade-in">get()</h4>

          <li class="fragment fade-in-then-semi-out">
            Given an entry hash or an action hash, return the "Record" that
            hashes to that hash
            <ul>
              <li class="fragment fade-in-then-semi-out">
                Record is the union of the action and optionally its
                accompanying entry
              </li>
            </ul>
          </li>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/coordinator/lib.rs
use hdk::prelude::*;
use integrity_zome::{EntryTypes, Comment}; // Import the types defined in our integrity zome
            
<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn get_comment(<span class="fragment fade-in">comment_action_hash: ActionHash</span>) -> ExternResult&lt;<span class="fragment fade-in">Option&lt;Record&gt;</span>&gt; {<span class="fragment fade-in-then-semi-out">
  <span class="fragment fade-in">let comment_record: Option&lt;Record&gt; =</span> get(<span class="fragment fade-in">comment_hash<span class="fragment popover fade-in-then-out">Accepts an "ActionHash" or an "EntryHash"</span></span><span class="fragment fade-in">, GetOptions::default()<span class="fragment fade-in-then-out popover">Cache control, by default return cached records</span></span>)?;

  <span class="fragment fade-in">Ok(comment_record)</span></span>
}</span>
</span></code></pre>
        </section>

        <section>
          <h3>Entry Retrievals</h3>
          <h4 class="fragment fade-in">get_details()</h4>

          <li class="fragment fade-in-then-semi-out">
            Given an entry hash, return the entry and all the actions that have
            created, updated or deleted any action pointing to that entry
          </li>
          <li class="fragment fade-in-then-semi-out">
            Given an action hash, return the entry and all the actions that have
            updated or deleted that action
          </li>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/coordinator/lib.rs
use hdk::prelude::*;
use integrity_zome::{EntryTypes, Comment}; // Import the types defined in our integrity zome

<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn get_comment_action_details(<span class="fragment fade-in">comment_action_hash: ActionHash</span>) -> ExternResult&lt;<span class="fragment fade-in">Record</span>&gt; {<span class="fragment fade-in-then-semi-out">
  <span class="fragment fade-in">let record_details: Option&lt;Details&gt; =</span> get_details(<span class="fragment fade-in">comment_action_hash<span class="fragment popover fade-in-then-out">Accepts an "ActionHash" or an "EntryHash"</span></span><span class="fragment fade-in">, GetOptions::default()<span class="fragment fade-in-then-out popover">Same options as "get()"</span></span>)?;

  <span class="fragment fade-in">match record_details {
    <span class="fragment fade-in">Some(Details::Record(RecordDetails { <span class="fragment fade-in">record, deletes, updates, .. </span>}))  => <span class="fragment fade-in">Ok(record),</span></span>
    <span class="fragment fade-in">_ => Err(wasm_error!(WasmErrorInner::Guest(String::from("Error trying to get the details of this action"))))</span>
  }</span></span>
}</span>
  
<span class="fragment fade-in-then-semi-out">#[hdk_extern]
fn get_comment_entry_details(<span class="fragment fade-in">comment_entry_hash: EntryHash</span>) -> ExternResult&lt;<span class="fragment fade-in">Entry</span>&gt; {<span class="fragment fade-in-then-semi-out">
  <span class="fragment fade-in">let entry_details: Option&lt;Details&gt; =</span> get_details(<span class="fragment fade-in">comment_entry_hash<span class="fragment popover fade-in-then-out">Accepts an "ActionHash" or an "EntryHash"</span></span><span class="fragment fade-in">, GetOptions::default()<span class="fragment fade-in-then-out popover">Same options as "get()"</span></span>)?;
  
  <span class="fragment fade-in">match entry_details {
    <span class="fragment fade-in">Some(Details::Entry(EntryDetails { <span class="fragment fade-in">entry, actions, deletes, updates, ..</span> })) => <span class="fragment fade-in">Ok(entry),</span></span>
    <span class="fragment fade-in">_ => Err(wasm_error!(WasmErrorInner::Guest(String::from("Error trying to get the details of this action"))))</span>
  }</span></span>
}</span>
</span></code></pre>
        </section>

        <section>
          <h3>Links</h3>

          <li class="fragment fade-in-then-semi-out">
            Linking from one hash to another, with some optional metadata
          </li>
          <li class="fragment fade-in-then-semi-out">
            Link components:
            <ul>
              <li class="fragment fade-in-then-semi-out">
                Base hash: can be public key, entry hash, action hash or
                external hash (the hash doesn't exist in this DHT)
              </li>
              <li class="fragment fade-in-then-semi-out">
                Target hash: can be of the same types as the base hash
              </li>
              <li class="fragment fade-in-then-semi-out">
                Type: app defined link type
              </li>
              <li class="fragment fade-in-then-semi-out">
                Tag: app defined arbitrary metadata
              </li>
            </ul>
          </li>
          <li class="fragment fade-in-then-semi-out">
            Neither the base nor the target hash need to exist as actions or entries in the DHT
          </li>
          <li class="fragment fade-in-then-semi-out">
            Defining link types
            <ul>
              <li class="fragment fade-in-then-semi-out">
                Only in integrity zomes
              </li>
            </ul>

            <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/integrity/lib.rs
use hdi::prelude::*;

// Defining link types
<span class="fragment fade-in"><span class="fragment fade-in">#[hdk_link_types]</span><span class="fragment popover fade-in-then-out"><li class="fragment fade-in-then-semi-out">Defines all the link types for this zome</li><li class="fragment fade-in-then-semi-out">Must be the only "#[hdk_link_types]" in the zome</li><li class="fragment fade-in-then-semi-out">Can only be defined in integrity zomes</li></span><span class="fragment fade-in"> // Defines all the link types for the zome</span>
enum LinkTypes { // Enum with each entry type as a variant
  <span class="fragment fade-in"> AuthorToComment,<span class="fragment fade-in-then-out popover">Must be a Unit variant (without any payload)</span> </span>
}
</span>
</span></code></pre>
          </li>
        </section>

        <section>
          <h3>Link Actions</h3>
          <h4 class="fragment fade-in">create_link()</h4>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/coordinator/lib.rs
use hdk::prelude::*;
<span class="fade-in">use integrity_zome::{LinkTypes, EntryTypes, Comment}; // Import the types defined in our integrity zome</span>

<span class="fragment fade-in">#[hdk_extern]
fn create_comment(comment: Comment) -> ExternResult&lt;ActionHash&gt; {
  <span class="fragment fade-in">let comment_action_hash = create_entry(EntryTypes::Comment(comment))?; // Create comment as always</span>

  <span class="fragment fade-in">let my_pub_key: AgentPubKey = agent_info()?.agent_initial_pubkey; <span class="fragment fade-in-then-out popover">The author of the comment is the agent executing this function call</span></span>

  <span class="fragment fade-in"><span class="fragment fade-in">let create_link_action_hash: ActionHash<span class="fragment fade-in-then-out popover">Creating a link is an action in itself</span> = </span>create_link(
    <span class="fragment fade-in">my_pub_key, <span class="fragment fade-in-then-out popover">Base hash: my agent pub key</span><span class="fragment fade-in">// Base hash</span></span>
    <span class="fragment fade-in">comment_action_hash,  <span class="fragment fade-in-then-out popover">Target hash: the action hash that has just been created</span><span class="fragment fade-in">// Target hash</span></span>
    <span class="fragment fade-in">LinkTypes::AuthorToComment,  <span class="fragment fade-in-then-out popover">LinkType: one of the variants defined in the integrity zome</span><span class="fragment fade-in">// Link Type</span></span>
    <span class="fragment fade-in">()<span class="fragment fade-in-then-out popover">Link tag, can be any struct that derives "Serialized" and "Deserialized"</span><span class="fade-in"> // Link tag</span></span>
  )?;</span>

  <span class="fragment fade-in">Ok(action_hash)</span>
}
</span></span></code></pre>
        </section>

        <section>
          <h3>Link Retrievals</h3>
          <h4 class="fragment fade-in">get_links()</h4>
          <li class="fragment fade-in-then-semi-out">
            Links are attached to the base hash
            <ul>
              <li class="fragment fade-in">
                You can retrieve all the links attached to a given hash as a
                base
              </li>
            </ul>
          </li>

          <pre><code class="rust" data-noescape><span class="fragment fade-in-then-semi-out">// zomes/coordinator/lib.rs
use hdk::prelude::*;
<span class="fade-in">use integrity_zome::{LinkTypes, EntryTypes, Comment}; // Import the types defined in our integrity zome</span>

<span class="fragment fade-in">#[hdk_extern]
fn get_all_comments_by_agent(author: AgentPubKey) -> ExternResult&lt;Vec&lt;Record&gt;&gt; {
  <span class="fragment fade-in"><span class="fragment fade-in">let links: Vec&lt;Link&gt;</span> = get_links(
    <span class="fragment fade-in">author, <span class="fragment fade-in-then-out popover">Base hash: the given agent pub key</span><span class="fragment fade-in"> // Base hash </span></span>
    <span class="fragment fade-in">LinkTypes::AuthorToComment, <span class="fragment fade-in-then-out popover">LinkType: one of the variants defined in the integrity zome</span><span class="fragment fade-in"> // Link Type </span></span>
    <span class="fragment fade-in">None, <span class="fragment fade-in-then-out popover">"Option&lt;LinkTag&gt;": prefix filter on link tag, if this has some tag starts with the given tag as their prefix will be returned </span><span class="fragment fade-in"> // Filter on link tag prefix </span></span>
  )?; </span>

  <span class="fragment fade-in">let mut comments: Vec<Record> = vec![];</span>

  <span class="fragment fade-in">for link in links {
    <span class="fragment fade-in">let maybe_record = get(<span class="fragment fade-in">ActionHash::from<span class="fragment fade-in-then-out popover">Conversion is important to specify the type of hash we are retrieving for</span>(link.target)<span class="fragment fade-in-then-out popover">Will be the action hash for each of the comments that the agent has created</span></span>, GetOptions::default())?;</span>
    <span class="fragment fade-in">if let Some(record) = maybe_record {
      comments.push(record);
    }</span>
  }</span>

  <span class="fragment fade-in">Ok(comments)</span>
}
</span>
</span></code></pre>
        </section>
      </div>
    </div>

    <script type="module">
      import Reveal from "reveal.js";
      import Markdown from "reveal.js/plugin/markdown/markdown.esm.js";
      import RevealHighlight from "reveal.js/plugin/highlight/highlight.esm.js";
      import RevealNotes from "reveal.js/plugin/notes/notes.esm.js";
      import RevealNestedFragments from "reveal.js-nested-fragments";

      let deck = new Reveal({
        transition: "none",
        plugins: [
          Markdown,
          RevealHighlight,
          RevealNotes,
          RevealNestedFragments,
        ],
      });
      deck.initialize();
    </script>
  </body>
</html>
